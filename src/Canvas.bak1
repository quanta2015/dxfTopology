import React, { useEffect, useRef, useState, useCallback, useMemo } from "react";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import DxfParser from "dxf-parser";
import "./Canvas.less";
import {
  drawEntity,
  disposeObject,
  normalizeRootToOriginByLines,
  fitCameraToBox,
  isRedColorByHex,
  getEntityDisplayName,
  getCategoryUniqueKey,
  isContainChinese
} from "./helper.js";

// ====== 分组定义：4个集合（用于 radio），3个按钮控制显示 ======
const GROUPS = [
  { key: "panel", label: "配电箱" },
  { key: "component", label: "元件" },
  { key: "wire", label: "电线" },
  { key: "other", label: "其他" }
];

export default function CanvasViewer({ mode = "fill", width = 1600, height = 900 }) {
  const mountRef = useRef(null);

  const rendererRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const controlsRef = useRef(null);

  const dxfRootRef = useRef(null);
  const animRef = useRef(0);
  const roRef = useRef(null);

  // ✅ 原有逻辑：只在加载 DXF 时 fit 一次
  const fittedOnceRef = useRef(false);

  const [err, setErr] = useState("");
  const [dxfText, setDxfText] = useState("");
  // ✅ 类别列表状态
  const [entityCategoryList, setEntityCategoryList] = useState([]);

  // ✅ 新增：类别 -> 集合（4个 radio 归类）
  const [categoryGroupMap, setCategoryGroupMap] = useState(() => ({}));

  // ✅ 新增：3个按钮控制显隐（配电箱+元件 / 电线 / 其他）
  const [groupVisibility, setGroupVisibility] = useState(() => ({
    main: true, // panel + component
    wire: true,
    other: false
  }));

  const mountStyle = useMemo(() => {
    if (mode === "fixed") return { width: `${width}px`, height: `${height}px` };
    return { width: "100%", height: "100%" };
  }, [mode, width, height]);

  // ====== 将 4个集合映射到 3个按钮开关 ======
  const isGroupVisible = useCallback((groupKey, vis) => {
    if (groupKey === "panel" || groupKey === "component") return vis.main;
    if (groupKey === "wire") return vis.wire;
    return vis.other;
  }, []);

  // ====== 根据“类别所属集合 + 集合开关”批量更新可见性 ======
  const applyVisibilityByGroups = useCallback(
    (list, groupMap, vis) => {
      list.forEach((category) => {
        const groupKey = groupMap[category.key] || "other";
        const show = isGroupVisible(groupKey, vis);
        category.objects.forEach((obj) => {
          obj.visible = show;
        });
      });
    },
    [isGroupVisible]
  );

  // ====== 类别行 radio 变更：重新归类 + 应用可见性 ======
  const handleCategoryGroupChange = useCallback(
    (categoryKey, nextGroupKey) => {
      setCategoryGroupMap((prev) => {
        const next = { ...prev, [categoryKey]: nextGroupKey };
        applyVisibilityByGroups(entityCategoryList, next, groupVisibility);
        return next;
      });
    },
    [applyVisibilityByGroups, entityCategoryList, groupVisibility]
  );

  // ====== 3 个按钮：切换集合显隐 ======
  const toggleGroupVisibility = useCallback(
    (which) => {
      setGroupVisibility((prev) => {
        const next = { ...prev, [which]: !prev[which] };
        applyVisibilityByGroups(entityCategoryList, categoryGroupMap, next);
        return next;
      });
    },
    [applyVisibilityByGroups, entityCategoryList, categoryGroupMap]
  );

  const loadDemo = useCallback(async () => {
    setErr("");
    try {
      const res = await fetch("/demo1.dxf");
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      setDxfText(await res.text());
    } catch (e) {
      setErr(`加载失败：${e.message}`);
    }
  }, []);

  useEffect(() => {
    loadDemo();
  }, [loadDemo]);

  // ====== three init / dispose ======
  useEffect(() => {
    const mount = mountRef.current;
    if (!mount) return;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x212121);
    sceneRef.current = scene;

    const camera = new THREE.OrthographicCamera(-500, 500, 500, -500, 1, 2_000_000);
    camera.position.set(0, 0, 1000);
    cameraRef.current = camera;

    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    rendererRef.current = renderer;
    mount.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableRotate = false;
    controls.mouseButtons = {
      LEFT: THREE.MOUSE.PAN,
      MIDDLE: THREE.MOUSE.DOLLY,
      RIGHT: THREE.MOUSE.PAN
    };
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.screenSpacePanning = true;
    controlsRef.current = controls;

    // cursor
    renderer.domElement.style.cursor = "default";
    const onDown = () => (renderer.domElement.style.cursor = "grabbing");
    const onUp = () => (renderer.domElement.style.cursor = "default");
    renderer.domElement.addEventListener("pointerdown", onDown);
    window.addEventListener("pointerup", onUp);

    const applySize = () => {
      const rect = mount.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      if (!w || !h) return;

      const aspect = w / h;
      const viewSize = Math.max(w, h) / 2;
      camera.left = (-viewSize * aspect) / 2;
      camera.right = (viewSize * aspect) / 2;
      camera.top = viewSize / 2;
      camera.bottom = -viewSize / 2;
      camera.updateProjectionMatrix();

      renderer.setSize(w, h, false);
      renderer.domElement.style.width = `${w}px`;
      renderer.domElement.style.height = `${h}px`;

      controls.update();
    };

    applySize();

    if (mode === "fill") {
      const ro = new ResizeObserver(() => applySize());
      ro.observe(mount);
      roRef.current = ro;
    }

    const animate = () => {
      animRef.current = requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    };
    animate();

    return () => {
      cancelAnimationFrame(animRef.current);

      if (roRef.current) {
        roRef.current.disconnect();
        roRef.current = null;
      }

      window.removeEventListener("pointerup", onUp);
      renderer.domElement.removeEventListener("pointerdown", onDown);

      if (dxfRootRef.current) {
        scene.remove(dxfRootRef.current);
        disposeObject(dxfRootRef.current);
        dxfRootRef.current = null;
      }

      fittedOnceRef.current = false;

      controls.dispose();
      renderer.dispose();
      if (renderer.domElement.parentElement) {
        renderer.domElement.parentElement.removeChild(renderer.domElement);
      }

      rendererRef.current = null;
      sceneRef.current = null;
      cameraRef.current = null;
      controlsRef.current = null;
    };
  }, [mode]);

  // ====== render DXF when text changes ======
  useEffect(() => {
    if (!dxfText) return;
    if (!sceneRef.current || !cameraRef.current || !controlsRef.current) return;

    try {
      renderDxfFromText(dxfText);
      setErr("");
    } catch (e) {
      console.error(e);
      setErr(`解析失败：${e.message || String(e)}`);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dxfText]);

  const renderDxfFromText = (text) => {
    const scene = sceneRef.current;
    const camera = cameraRef.current;
    const controls = controlsRef.current;

    if (dxfRootRef.current) {
      scene.remove(dxfRootRef.current);
      disposeObject(dxfRootRef.current);
      dxfRootRef.current = null;
    }

    const parser = new DxfParser();
    const dxf = parser.parseSync(text);

    const tables = dxf.tables || {};
    const blocks = dxf.blocks || {};
    tables.blocks = blocks;
    tables.layers = dxf.tables?.layer?.layers ? dxf.tables.layer.layers : {};

    const root = new THREE.Group();
    (dxf.entities || []).forEach((ent) => {
      const obj = drawEntity(ent, tables, true, null);
      if (obj) root.add(obj);
    });

    // ✅ 原有逻辑：将图形移到原点
    normalizeRootToOriginByLines(root);
    scene.add(root);
    dxfRootRef.current = root;

    // ====== 分类收集数据（LWPOLYLINE/LINE按颜色细分） ======
    const entityStats = {};
    const dxfBlocks = blocks;

    root.traverse((obj) => {
      if (obj.userData && obj.userData.isTopLevel) {
        const userData = obj.userData;
        const name = getEntityDisplayName(userData, dxfBlocks);
        const color = userData.baseColor || 0xffffff;
        const categoryKey = getCategoryUniqueKey(userData, name, color);

        if (!entityStats[categoryKey]) {
          entityStats[categoryKey] = {
            key: categoryKey,
            name,
            type: userData.type,
            blockName: userData.name || "N/A",
            layer: userData.layer || "N/A",
            color: color,
            objects: [],
            count: 0
          };
        }

        entityStats[categoryKey].objects.push(obj);
        entityStats[categoryKey].count = entityStats[categoryKey].objects.length;
      }
    });

    const newEntityCategoryList = Object.values(entityStats).sort((a, b) => b.count - a.count);
    setEntityCategoryList(newEntityCategoryList);

    // ====== 新逻辑：初始化“类别->集合”映射（4个 radio） ======
    const initialGroupMap = {};
    newEntityCategoryList.forEach((category) => {
      // 默认：其他
      let g = "other";

      if ((category.type === "LINE" || category.type === "LWPOLYLINE") && isRedColorByHex(category.color)) {
        g = "wire";
      } else if (isContainChinese(category.name)) {
        if (/配电箱/.test(category.name)) {
          g = "panel";
        } else {
          g = "component";
        }
      } else {
        g = "other";
      }

      initialGroupMap[category.key] = g;
    });

    setCategoryGroupMap(initialGroupMap);

    // 初始按集合开关应用可见性（默认 main/wire/other 都 true => 全显示）
    applyVisibilityByGroups(newEntityCategoryList, initialGroupMap, groupVisibility);

    // ✅ 原有逻辑：首次加载适配相机
    fittedOnceRef.current = false;
    if (!fittedOnceRef.current) {
      fitCameraToBox(root, camera, controls);
      fittedOnceRef.current = true;
    }
  };

  return (
    <>
      <div className={`viewerRoot ${mode === "fill" ? "viewerFill" : "viewerFixed"}`}>
        <div ref={mountRef} className="threeMount" style={mountStyle} />
        {err ? <div className="err">{err}</div> : null}
      </div>

      {/* Detail区域（按类别显示 4个radio 归类 + 3个按钮控制显示） */}
      <div className="detail">
        <div className="dxf-detail-panel">
          <div className="detail-header">
            <div className="select-all-wrapper" style={{ display: "flex", gap: 8, flexWrap: "wrap" }}>
              <button
                type="button"
                className={`group-btn ${groupVisibility.main ? "on" : "off"}`}
                onClick={() => toggleGroupVisibility("main")}
              >
                显示配电箱和元件
              </button>
              <button
                type="button"
                className={`group-btn ${groupVisibility.wire ? "on" : "off"}`}
                onClick={() => toggleGroupVisibility("wire")}
              >
                显示电线
              </button>
              <button
                type="button"
                className={`group-btn ${groupVisibility.other ? "on" : "off"}`}
                onClick={() => toggleGroupVisibility("other")}
              >
                显示其他
              </button>
            </div>
          </div>

          {/* 类别列表 */}
          <div className="entity-category-list">
            <div className="category-item">
              <div className="category-radios">
                <span>电箱</span>
                <span>元件</span>
                <span>电线</span>
                <span>其他</span>
              </div>
              <div className="category-label">名称</div>
            </div>
            {entityCategoryList.length === 0 ? (
              <div className="empty-tip">未找到可统计的DXF元素类别</div>
            ) : (
              entityCategoryList
                .sort((a, b) => a.name.localeCompare(b.name))
                .map((category) => {
                  const colorStr = "#" + category.color.toString(16).padStart(6, "0");
                  const currentGroup = categoryGroupMap[category.key] || "other";

                  return (
                    <div key={category.key} className="category-item">
                      {/* 左侧：4个 radio */}
                      <div className="category-radios">
                        {GROUPS.map((g) => {
                          const radioId = `${category.key}__${g.key}`;
                          return (
                            <span key={g.key}>
                              <input
                                type="radio"
                                id={radioId}
                                name={`group_${category.key}`}
                                checked={currentGroup === g.key}
                                onChange={() => handleCategoryGroupChange(category.key, g.key)}
                              />
                            </span>
                          );
                        })}
                      </div>

                      {/* 右侧：类别信息 */}
                      <div className="category-label">
                        <div className="category-color" style={{ background: colorStr }}></div>
                        <div className="category-info">
                          <i>{category.name}</i>
                          <span>{category.count}</span>
                        </div>
                      </div>
                    </div>
                  );
                })
            )}
          </div>
        </div>
      </div>
    </>
  );
}
